## 5.5 process guess(guess: str, answer: str) -> str

Returns a modified representation of guess, in which each letter is replaced by:

-   A green square if that letter occurs in the same position in answer.
    -   å¦‚æœè¯¥å­—æ¯åœ¨ç­”æ¡ˆä¸­å‡ºç°åœ¨åŒä¸€**ä½ç½®**ï¼Œåˆ™ä¸º**ç»¿è‰²**æ–¹å—ã€‚âœ…

-   A yellow square if that letter occurs in a different position in answer.
    -   å¦‚æœè¯¥å­—æ¯åœ¨ç­”æ¡ˆä¸­å‡ºç°åœ¨ä¸åŒçš„ä½ç½®ï¼Œåˆ™ä¸ºé»„è‰²æ–¹å—ã€‚âœ…

-   A black square if that letter does not occur in answer.
    -   å¦‚æœè¯¥å­—æ¯æ²¡æœ‰å‡ºç°åœ¨ç­”æ¡ˆä¸­ï¼Œåˆ™ä¸ºé»‘è‰²æ–¹å—ã€‚âœ…

While answers must contain 6 unique letters, guesses may contain duplicate letters. 

è™½ç„¶ answer å¿…é¡»åŒ…å« 6 ä¸ª**ç‹¬ç‰¹**çš„å­—æ¯ï¼Œä½† guess å¯èƒ½åŒ…å«é‡å¤çš„å­—æ¯ã€‚**ã€Œanswer å•è¯ä¸é‡å¤ã€**

If duplicate letters exist in the guess, only one can have a non-black square. 

å¦‚æœ guess ä¸­å­˜åœ¨é‡å¤çš„å­—æ¯ï¼Œåªæœ‰ä¸€ä¸ªå­—æ¯å¯ä»¥æœ‰éé»‘è‰²çš„æ–¹å—ï¼ˆé»„è‰²æˆ–è€…ç»¿è‰²ï¼‰ã€‚

If the letter does exist in answer, the non-black square is allocated as follows:

å¦‚æœè¯¥å­—æ¯åœ¨ answer ä¸­å­˜åœ¨ï¼Œé‚£ä¹ˆéé»‘è‰²æ–¹å—çš„åˆ†é…æ–¹å¼å¦‚ä¸‹ã€‚

1. If one of the occurrences is in the correct position, it receives a green square and all other occurrences receive a black square.

å¦‚æœå…¶ä¸­ä¸€ä¸ªå‡ºç°åœ¨æ­£ç¡®çš„ä½ç½®ä¸Šï¼Œå®ƒå°±ä¼šå¾—åˆ°ä¸€ä¸ªç»¿è‰²çš„æ–¹å—ï¼Œå…¶ä»–çš„å‡ºç°éƒ½ä¼šå¾—åˆ°ä¸€ä¸ªé»‘è‰²çš„æ–¹å—ã€‚âœ…

2. Otherwise, if no occurrences are in the correct position, the first occurrence of the letter in guess receives a yellow square and all other occurrences receive a black square.

  å¦åˆ™ï¼Œå¦‚æœæ²¡æœ‰å‡ºç°åœ¨æ­£ç¡®çš„ä½ç½®ä¸Šï¼Œguess ä¸­çš„å­—æ¯çš„ç¬¬ä¸€æ¬¡å‡ºç°ä¼šå¾—åˆ°ä¸€ä¸ªé»„è‰²çš„æ–¹å—ï¼Œæ‰€æœ‰å…¶ä»–çš„å‡ºç°ä¼šå¾—åˆ°ä¸€ä¸ªé»‘è‰²çš„æ–¹å—ã€‚

  the second 'r' gets non-black square because it is in the right position

  ç¬¬äºŒä¸ª 'r' å¾—åˆ°éé»‘è‰²æ–¹å—ï¼Œå› ä¸ºå®ƒåœ¨æ­£ç¡®çš„ä½ç½®ä¸Šã€‚ã€Œç¬¬äºŒä¸ª â€˜r'  å¾—åˆ°ç»¿è‰²æ–¹å—ï¼Œå› ä¸ºåœ¨æ­£ç¡®çš„ä½ç½® ã€

  ```python
  process_guess('arrows', 'strand')
  ğŸŸ¨â¬›ğŸŸ©â¬›â¬›ğŸŸ¨
  ```

  the first 'r' gets the non-black square because no r's are in the right postition but r exist in the answer. 

â€‹    

  ç¬¬ä¸€ä¸ªâ€™râ€˜ å¾—åˆ°é»„è‰²æ–¹å—ï¼Œå› ä¸ºæ²¡æœ‰â€™r' åœ¨æ­£ç¡®çš„ä½ç½®ï¼Œä½†rå­˜åœ¨äºanswerä¸­

  ```python
  process_guess('arrows', 'answer')
  ğŸŸ©ğŸŸ¨â¬›â¬›ğŸŸ¨ğŸŸ¨
  ```

```python
green = "ğŸŸ©"
yellow = "ğŸŸ¨"
black = "â¬›"


def process_guess(guess, answer):
	# print(CORRECT + MISPLACED + INCORRECT)
	template = ""
	BASE = (0, 1, 2, 3, 4, 5)
	if len(guess) == 6 and len(answer) == 6:
		guess_lst = list(zip(list(guess), BASE))  # è¿™æ˜¯å¾—åˆ°æ¯ä¸ªå…ƒç´ çš„ä¸‹æ ‡
		answer_lst = list(zip(list(answer), BASE))
		# print(guess_lst)
		# print(answer_lst)
		for g_w, g_p in guess_lst:
			if g_w not in answer:
				template += black
			else:
				i = 0
				for a_w, a_p in answer_lst:
					# if guess.count(g_w) >= 2 and i == 0 and g_p == a_p:
					# 	# template += MISPLACED  # é»„è‰²
					# 	template += green  # ç»¿è‰²
					# 	i += 1
					# elif guess.count(g_w) >= 2 and i == 1 and g_p != a_p:
					# 	template += black  # é»‘è‰²
					# 	i += 1
					# elif guess.count(g_w) >= 2 and g_p == a_p:
					# 	template += CORRECT  # ç»¿è‰²
					if g_w == a_w and g_p == a_p:  # å­—æ¯ç›¸åŒã€‚ä½ç½®ç›¸åŒ
						template += green  # ç»¿è‰²
					elif g_w == a_w and g_p != a_p:
						template += yellow  # é»„è‰²
					elif guess.count(g_w) > 1:
						if g_w in answer:
							if g_w == a_w and g_p == a_p:
								"""å¦‚æœå…¶ä¸­ä¸€ä¸ªå‡ºç°åœ¨æ­£ç¡®çš„ä½ç½®ä¸Šï¼Œå®ƒå°±ä¼šå¾—åˆ°ä¸€ä¸ªç»¿è‰²çš„æ–¹å—"""
								template += green
								i += 1
								# if g_p != a_p:
								# 	template += black
							elif g_w == a_w and g_p != a_p:
								if i == 0:
									template += yellow
									i += 1
								elif i >= 1:
									"""å…¶ä»–çš„å‡ºç°éƒ½ä¼šå¾—åˆ°ä¸€ä¸ªé»‘è‰²çš„æ–¹å—ã€‚"""
									template += black
							# elif g_w == a_w and g_p == a_p and i == 0:
							# 	template += black
							# else:
							# 	template += black
		# print(template)
		return (guess, template)
	else:
		return None

# 1. guess çš„å­—æ¯è·Ÿ answer çš„ç›¸åŒå¹¶ä¸”ä½ç½®ç›¸åŒï¼Œé‚£å°±æ˜¾ç¤ºæˆç»¿è‰²æ–¹å—
# 2. å¦‚æœå­—æ¯ç›¸åŒä½ç½®ä¸åŒï¼Œæ˜¾ç¤ºæˆé»„è‰²æ–¹å—ï¼Œéƒ½ä¸æ˜¯æ˜¾ç¤ºé»‘è‰²æ–¹å—ï¼Œ
# å¦‚æœ guess é‡Œé¢æœ‰ä¸¤ä¸ªè·Ÿ answer å…¶ä¸­ä¸€ä¸ªå­—æ¯ç›¸åŒï¼Œåªèƒ½æœ‰ä¸€ä¸ªæ˜¯é»„è‰²æ–¹å—ï¼Œå¦ä¸€ä¸ªæ˜¯é»‘è‰²æ–¹å—
if __name__ == '__main__':
	process_guess("debunk", "dances")
	process_guess("candle", "dances")
	process_guess("arrows", "strand")
	process_guess("arrows", "answer")
```





## 5.6 update history( history: tuple[tuple[str, str], ...], guess: str, answer: str ) -> tuple[tuple[str, str], ...]

è¿”å›å†å²è®°å½•çš„å‰¯æœ¬ï¼ŒåŒ…æ‹¬æœ€æ–°çš„ guess å’Œå®ƒçš„å¤„ç†å½¢å¼ (process_guess)ã€‚

Returns a copy of history updated to include the latest guess and its processed form. 

å‚è§ç¬¬ 5.7 èŠ‚ï¼Œäº†è§£è¯¥å‡½æ•°çš„ä½¿ç”¨å®ä¾‹ã€‚

history æ˜¯ä¸€ä¸ª**å…ƒç»„**ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªï¼ˆguessï¼Œprocess_guessï¼‰çš„å…ƒç»„ã€‚

See Section 5.7 for example usage of this function. history is a tuple where each element is a tuple of (guess, processed_guess). 

Prints the guess history in a user-friendly way.

![image-20220331224049238](åˆ˜ä¸€é¸£-æ¾³å¤§åˆ©äºš-ITã€Œ02ã€.assets/image-20220331224049238.png)

```python
from lesson04 import process_guess


def update_history(history, guess, answer):
	his = process_guess(guess, answer)
	# print(his)
	history += (his, )
	return history

def print_history(history):
	index = 1
	for guess, over in history:
		g_lst = list(guess)
		o_lst = list(over)
		d = dict(zip(g_lst, o_lst))
		print(d)
		template = f"""
---------------
Guess {index}:{g_lst[0]}{g_lst[1]}{g_lst[2]}{g_lst[3]}{g_lst[4]}{g_lst[5]}
{over[0]}{over[1]}{over[2]}{over[3]}{over[4]}{over[5]}
---------------
		"""
		index += 1
		print(template)



answer = "dances"
history = ()

history = update_history(history, 'Python', answer)
print(history)

history = update_history(history, 'debunk', answer)
print(history)

print_history(history)
```





## 5.8 print keyboard(history: tuple[tuple[str, str], ...]) -> None

5.8 ä»¥ç”¨æˆ·å‹å¥½çš„æ–¹å¼æ‰“å°é”®ç›˜ä¸Šå½“å‰å·²çŸ¥çš„æ¯ä¸ªå­—æ¯çš„ä¿¡æ¯ã€‚

5.8 Prints the keyboard in a user-friendly way with the information currently known about each letter.

è¿™ä¸¤åˆ—æ˜¯ä»¥åˆ¶è¡¨ç¬¦åˆ†éš”çš„ã€‚Note that the two columns are tab-separated.statsæ˜¯ä¸€ä¸ªåŒ…å«7ä¸ªå…ƒç´ çš„å…ƒç»„ï¼Œåˆ†åˆ«æ˜¯1-6ä¸ªçŒœæµ‹ä¸­èµ¢å¾—çš„å›åˆæ•°ã€‚å’Œè¾“æ‰çš„å›åˆæ•°ï¼Œåˆ†åˆ«æ˜¯ã€‚stats is a tuple containing seven elements, which are the number of rounds won in 1-6 guesses, and the number of rounds lost, respectively. 
è¿™ä¸ªå‡½æ•°ä»¥ä¸€ç§ç”¨æˆ·å‹å¥½çš„æ–¹å¼æ‰“å°å‡ºç»Ÿè®¡æ•°å­—ã€‚This function prints the stats in a user-friendly way.

![image-20220331235832667](åˆ˜ä¸€é¸£-æ¾³å¤§åˆ©äºš-ITã€Œ02ã€.assets/image-20220331235832667.png)

æç¤ºï¼š

```python
history = (('Python', 'â¬›â¬›â¬›â¬›â¬›ğŸŸ¨'), ('debunk', 'ğŸŸ©ğŸŸ¨â¬›â¬›ğŸŸ¨â¬›'))


s = "Aã€Bã€Cã€Dã€Eã€Fã€Gã€Hã€Iã€Jã€Kã€Lã€Mã€Nã€Oã€Pã€Qã€Rã€Sã€Tã€Uã€Vã€Wã€Xã€Yã€Z"
new_s = s.lower().replace("ã€", "")
even_word = new_s[::2]
odd_word = new_s[1::2]
print(odd_word)
# template = "{}:{}\t\t{}:{}\n"
# template = "{}:{}\t\t{}:{}\n"*13
lst = zip(even_word, odd_word)
# print(template)
f_k = ""
for e, o in lst:
	template = f"{e}:{f_k}\t\t{o}:{f_k}\n"
	print(template, end="")
# s = """
# a:
# """
# a:		b:
# c:		d:
# e:		f:
# g:		h:
# i:		j:
# k:		l:
# m:		n:
# o:		p:
# q:		r:
# s:		t:
# u:		v:
# w:		x:
# y:		z:
```



